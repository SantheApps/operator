import { Cron } from 'croner';
import { watch } from 'chokidar';
import path from 'node:path';
import { appendFile, mkdir } from 'node:fs/promises';
import { MemoryStore } from '../memory/store.js';
import { GoalStore, type Task } from '../goals/store.js';
import { loadTriggers, type TriggerConfig } from './triggers.js';
import { getAgentDir } from '../utils/paths.js';

/**
 * Daemon Service ‚Äî The autonomous agent heartbeat
 *
 * Runs as a long-lived background process that:
 * - Processes the goal/task queue
 * - Watches files for changes
 * - Runs cron-scheduled tasks
 * - Logs all activity
 */
export class DaemonService {
    private cronJobs: Cron[] = [];
    private fileWatchers: ReturnType<typeof watch>[] = [];
    private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
    private memoryStore: MemoryStore;
    private goalStore: GoalStore;
    private logPath: string;
    private running = false;
    private startedAt: Date | null = null;
    private stats = {
        tasksProcessed: 0,
        tasksCompleted: 0,
        tasksFailed: 0,
        triggersFireCount: 0,
        heartbeats: 0,
    };

    constructor(private workDir: string = process.cwd()) {
        this.memoryStore = MemoryStore.open(workDir);
        this.goalStore = new GoalStore(this.memoryStore);
        this.logPath = path.join(getAgentDir(), 'daemon.log');
    }

    /**
     * Start the daemon service
     */
    async start(): Promise<void> {
        if (this.running) return;
        this.running = true;
        this.startedAt = new Date();

        await this.log('üü¢ Agent daemon started');
        await this.log(`   Working directory: ${this.workDir}`);

        // Load and register triggers
        const triggers = await loadTriggers(this.workDir);
        await this.log(`   Loaded ${triggers.length} trigger(s)`);

        for (const trigger of triggers) {
            await this.registerTrigger(trigger);
        }

        // Start heartbeat (every 60 seconds)
        this.heartbeatTimer = setInterval(() => this.heartbeat(), 60_000);

        // Run initial goal check
        await this.processGoalQueue();

        // Keep the process alive
        process.on('SIGTERM', () => this.shutdown());
        process.on('SIGINT', () => this.shutdown());

        await this.log('   Daemon is ready. Waiting for events...');
    }

    /**
     * Register a trigger
     */
    private async registerTrigger(trigger: TriggerConfig): Promise<void> {
        switch (trigger.event) {
            case 'cron':
            case 'goal.check':
                if (trigger.schedule) {
                    const job = new Cron(trigger.schedule, async () => {
                        await this.onTriggerFired(trigger);
                    });
                    this.cronJobs.push(job);
                    await this.log(`   üìÖ Cron registered: "${trigger.name}" ‚Üí ${trigger.schedule}`);
                }
                break;

            case 'file.changed':
                if (trigger.watch) {
                    const paths = Array.isArray(trigger.watch) ? trigger.watch : [trigger.watch];
                    const watcher = watch(paths, {
                        cwd: this.workDir,
                        ignoreInitial: true,
                        awaitWriteFinish: {
                            stabilityThreshold: trigger.debounce ?? 2000,
                        },
                    });

                    let debounceTimer: ReturnType<typeof setTimeout> | null = null;

                    const handleChange = (filePath: string) => {
                        if (debounceTimer) clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(async () => {
                            await this.onTriggerFired(trigger, { changedFile: filePath });
                        }, trigger.debounce ?? 2000);
                    };

                    watcher.on('change', handleChange);
                    watcher.on('add', handleChange);

                    this.fileWatchers.push(watcher);
                    await this.log(`   üëÅÔ∏è Watcher registered: "${trigger.name}" ‚Üí ${paths.join(', ')}`);
                }
                break;

            default:
                await this.log(`   ‚ö†Ô∏è Unknown trigger event: ${trigger.event}`);
        }
    }

    /**
     * Handle a trigger firing
     */
    private async onTriggerFired(trigger: TriggerConfig, _context?: Record<string, any>): Promise<void> {
        this.stats.triggersFireCount++;

        if (trigger.action.type === 'goal-progress') {
            await this.processGoalQueue();
            return;
        }

        if (trigger.action.skill) {
            await this.log(`‚ö° Trigger "${trigger.name}" fired ‚Üí skill: ${trigger.action.skill}`);
            // In a full implementation, this would invoke the skill runner
            // For now, log the trigger and create a task if there's an active goal
            await this.log(`   Skill execution: ${trigger.action.skill} (queued)`);
        }

        if (trigger.action.run) {
            await this.log(`‚ö° Trigger "${trigger.name}" fired ‚Üí run: ${trigger.action.run}`);
            try {
                const { exec } = await import('node:child_process');
                const { promisify } = await import('node:util');
                const execAsync = promisify(exec);
                const { stdout, stderr } = await execAsync(trigger.action.run, {
                    cwd: this.workDir,
                    timeout: 30_000,
                });
                if (stdout) await this.log(`   stdout: ${stdout.trim()}`);
                if (stderr) await this.log(`   stderr: ${stderr.trim()}`);
            } catch (err) {
                await this.log(`   ‚úó Command failed: ${(err as Error).message}`);
            }
        }
    }

    /**
     * Process the goal/task queue
     */
    private async processGoalQueue(): Promise<void> {
        const task = this.goalStore.getNextTask();
        if (!task) return;

        this.stats.tasksProcessed++;
        await this.log(`üîÑ Processing task #${task.id}: "${task.title}"`);

        this.goalStore.startTask(task.id);

        try {
            // Execute the task
            const result = await this.executeTask(task);

            this.goalStore.completeTask(task.id, result);
            this.stats.tasksCompleted++;
            await this.log(`‚úÖ Task #${task.id} completed: ${result.slice(0, 100)}`);

            // Auto-save completion as a memory
            this.memoryStore.save(
                `Completed task: "${task.title}" ‚Äî ${result.slice(0, 200)}`,
                'learned',
                'agent',
                ['task', 'completed']
            );

            // Check if there are more tasks to process
            await this.processGoalQueue();

        } catch (err) {
            const error = (err as Error).message;
            this.goalStore.failTask(task.id, error);
            this.stats.tasksFailed++;
            await this.log(`‚ùå Task #${task.id} failed: ${error}`);
        }
    }

    /**
     * Execute a single task
     */
    private async executeTask(task: Task): Promise<string> {
        if (task.skill) {
            // In full implementation, this invokes the skill runner with the LLM
            // For now, use shell execution for skills that have runnable commands
            return `Task "${task.title}" processed (skill: ${task.skill})`;
        }

        // If no skill, treat as a simple logged action
        return `Task "${task.title}" processed`;
    }

    /**
     * Heartbeat ‚Äî periodic health check
     */
    private async heartbeat(): Promise<void> {
        if (!this.running) return;
        this.stats.heartbeats++;

        // Check for pending approvals
        const approvals = this.goalStore.getPendingApprovals();
        if (approvals.length > 0) {
            await this.log(`üí° ${approvals.length} task(s) awaiting approval`);
        }

        // Check for active goals
        const goalStats = this.goalStore.stats();
        if (goalStats.runningTasks > 0 || goalStats.pendingTasks > 0) {
            await this.log(
                `üìä Heartbeat: ${goalStats.activeGoals} goals, ` +
                `${goalStats.pendingTasks} pending, ${goalStats.runningTasks} running`
            );
        }
    }

    /**
     * Graceful shutdown
     */
    private async shutdown(): Promise<void> {
        await this.log('üî¥ Daemon shutting down...');
        this.running = false;

        // Stop heartbeat
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
        }

        // Stop cron jobs
        for (const job of this.cronJobs) {
            job.stop();
        }

        // Stop file watchers
        for (const watcher of this.fileWatchers) {
            await watcher.close();
        }

        const uptime = this.getUptime();
        await this.log(
            `   Uptime: ${uptime} | ` +
            `Tasks: ${this.stats.tasksProcessed} processed, ` +
            `${this.stats.tasksCompleted} completed, ` +
            `${this.stats.tasksFailed} failed`
        );
        await this.log('   Goodbye.\n');

        process.exit(0);
    }

    /**
     * Get daemon uptime as human-readable string
     */
    private getUptime(): string {
        if (!this.startedAt) return '0s';
        const ms = Date.now() - this.startedAt.getTime();
        const seconds = Math.floor(ms / 1000) % 60;
        const minutes = Math.floor(ms / 60000) % 60;
        const hours = Math.floor(ms / 3600000) % 24;
        const days = Math.floor(ms / 86400000);

        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0) parts.push(`${minutes}m`);
        parts.push(`${seconds}s`);
        return parts.join(' ');
    }

    /**
     * Get current daemon status
     */
    getStatus() {
        return {
            running: this.running,
            startedAt: this.startedAt?.toISOString() ?? null,
            uptime: this.getUptime(),
            stats: { ...this.stats },
            cronJobs: this.cronJobs.length,
            fileWatchers: this.fileWatchers.length,
        };
    }

    /**
     * Log a message to the daemon log file
     */
    private async log(message: string): Promise<void> {
        const timestamp = new Date().toISOString();
        const line = `[${timestamp}] ${message}\n`;

        // Ensure log directory exists
        await mkdir(path.dirname(this.logPath), { recursive: true });
        await appendFile(this.logPath, line, 'utf-8');

        // Also print to stdout (visible in daemon logs)
        console.log(`${timestamp.slice(11, 19)} ${message}`);
    }
}

// Auto-start if run as the daemon process
if (process.argv[1]?.endsWith('service.js')) {
    const service = new DaemonService();
    service.start().catch(err => {
        console.error('Fatal daemon error:', err);
        process.exit(1);
    });
}
